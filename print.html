<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Thespis User Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="actor_model.html"><strong aria-hidden="true">2.</strong> What is the actor model?</a></li><li class="chapter-item expanded "><a href="what_is_thespis.html"><strong aria-hidden="true">3.</strong> What is thespis?</a></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">4.</strong> Pitfalls Checklist</a></li><li class="chapter-item expanded "><a href="local.html"><strong aria-hidden="true">5.</strong> !Send Actors</a></li><li class="chapter-item expanded "><a href="thespis_impl/thespis_impl.html"><strong aria-hidden="true">6.</strong> thespis_impl</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="thespis_impl/desugar.html"><strong aria-hidden="true">6.1.</strong> Desugar Addr::builder()</a></li><li class="chapter-item expanded "><a href="thespis_impl/supervision.html"><strong aria-hidden="true">6.2.</strong> Supervising an actor</a></li><li class="chapter-item expanded "><a href="thespis_impl/concurrent.html"><strong aria-hidden="true">6.3.</strong> Processing messages concurrently</a></li><li class="chapter-item expanded "><a href="thespis_impl/abstraction.html"><strong aria-hidden="true">6.4.</strong> Abstract the Actor type</a></li><li class="chapter-item expanded "><a href="thespis_impl/debugging.html"><strong aria-hidden="true">6.5.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="thespis_impl/backpressure.html"><strong aria-hidden="true">6.6.</strong> Backpressure</a></li></ol></li><li class="chapter-item expanded "><a href="thespis_remote/introduction.html"><strong aria-hidden="true">7.</strong> thespis_remote</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="thespis_remote/service_map.html"><strong aria-hidden="true">7.1.</strong> ServiceMap</a></li><li class="chapter-item expanded "><a href="thespis_remote/peer.html"><strong aria-hidden="true">7.2.</strong> Peer</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Thespis User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the user guide for the Thespis actor library. The actor model is an entire programming paradigm. Thus if you have no experience with it, there is some ground to cover before becoming fluid in designing software with this model. This guide will provide you with the following information:</p>
<ol>
<li>Some references to good information about the actor model itself</li>
<li>A detailed tour of both the features and the design choices of Thespis.</li>
<li>A set of design patterns that can help you solve common problems with the actor model and more specifically with Thespis.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-the-actor-model"><a class="header" href="#what-is-the-actor-model">What is the actor model?</a></h1>
<p>The actor model is a program design model tailored to asynchronous concurrent processing. It was first conceived in 1973 by Carl Hewitt.  <a href="https://en.wikipedia.org/wiki/Actor_model">Wikipedia</a> has a thorough introduction.</p>
<p>To simplify, the actor model is an object oriented model which encapsulates not only data but also behavior. That is an actor is an object which can hold local mutable state, but other actors cannot access the state, neither call methods on the actor. The only way to interact with it is by sending it a message.</p>
<p>This is the key advantage of the actor model. Since no direct method calls take place, there is no shared memory access. There is no need for locking as only the actor itself will be able to access it's state. The actor processes one message at a time. Thus during message processing it is always guaranteed to be the only piece of the program accessing it's state and no synchronization is needed.</p>
<p>You might have found out that people struggle to use the OOP model in Rust. Rust doesn't allow you to cheat when it comes to memory access. The compiler is very strict and it turns out its hard to write traditional OOP with a strict compiler. When you add concurrency and multi-threading to the mix it becomes downright impractical. The actor model solves exactly this problem as memory synchronization is simple eliminated from the equation.</p>
<p>For the rest of this book, it is assumed that you have some basic understanding of how the actor model works. If this is new for you, please check the following resources:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Actor_model">Wikipedia</a></li>
<li><a href="https://www.youtube.com/watch?v=7erJ1DV_Tlo">Everything you ever wanted to know about the actor model by Carl Hewitt</a> (video, highly recommended)</li>
</ul>
<p>The Thespis API is inpired by <a href="https://docs.rs/actix/">actix</a>. If you are already familiar with actix, it will be easy to pick up thespis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-thespis"><a class="header" href="#what-is-thespis">What is thespis?</a></h1>
<p>When working on asynchronous projects in Rust I discovered the actor model thanks to <a href="https://docs.rs/actix/">actix</a>. I immediately found the model a very good fit for both Rust and asynchronous design. I started to implement software using the actix library and soon ran into a number of issues:</p>
<ul>
<li>it was in futures 0.1 (has been updated by now)</li>
<li>doesn't work on wasm</li>
<li>documentation was lackluster</li>
<li>code base big and complicated</li>
<li>didn't have remote actors</li>
<li>my reasoning didn't seem to match with the actix lead developer</li>
</ul>
<p>I tried briefly to evaluate what it would take to implement the features I wanted in actix, but it turned out to be complicated. Thus I set off rewriting from scratch. It has taken a long time, but I think the result is still relevant and worth it.</p>
<p>In the mean time, so many actor libraries have popped up that I have lost track of what each one exactly offers, you'll have to do your own research. Here is a list: <a href="https://lib.rs/search?q=actor">lib.rs/search?q=actor</a>.</p>
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li><strong>Interfaces</strong>: Interface and implementation are separate. The behavior of an actor is described in the <em>thespis</em> crate with traits. <em>thespis_impl</em> has a reference implementation. However, libraries can expose an actor API without having to pull in an implementation, just by implementing the traits. Clients can choose their implementation and aren't obliged to use the reference implementation.</li>
<li><strong>works on Wasm</strong>: Note that async rust on embedded is still in it's infancy and I have not looked into it specifically, so no promises there for now. Thespis also uses boxing extensively, which might be a problem on <code>#[no_std]</code>.</li>
<li><strong>minimal API design</strong> As an example compared to actix, there is no <code>MessageResponse</code> trait, no <code>Context</code> object, no <code>ActorFuture</code>, no DNS resolver, no <code>System</code> nor <code>Arbiter</code>, no <code>ActorStream</code>, ... yet it does about everything you can do with actix and more. The code base (without remote actors) is about 1.2k SLOC.</li>
<li><strong>abstractions</strong>: The address in thespis implements the <em>Sink</em> trait, so you can easily chain it with streams. Make an actor observable with <a href="https://crates.io/crates/pharos"><em>pharos</em></a> and you have a pub-sub pattern. You can plug in the channel of your choice between the address and the <code>Mailbox</code> (<code>Mailbox</code> only requires you give it a <code>Stream</code>). You can even have different channels for different addresses to the same <code>Mailbox</code>. You can use combinators on the receiving end to have different priorities depending on the address.</li>
<li><strong>full control</strong>: you can interact at a low level with the address and the mailbox of an actor, you can change their implementation for your own as long as they implement the required traits.</li>
<li><strong>remote actors</strong>: <em>thespis_remote</em> is a library that allows you to communicate with other processes and send messages to a remote process as if it was an actor in the local application. As far as I can tell, <a href="https://docs.rs/kay"><em>kay</em></a> is the only other Rust actor library that has remote actors.</li>
<li><strong>supervision</strong>: <em>thespis_impl</em> supports supervision without even needing a <code>Supervisor</code> type.</li>
<li><strong>performant</strong>: I need to run some more tests, but we seem to be about twice as fast as actix in most scenarios. There is one notable exception. Under contention, that is one receiver with many senders on different threads, actix is about 3 times faster. Somehow they spread more work on the sender threads, and in this case the receiver thread is the bottleneck, so that works really well.</li>
<li><strong>executor agnostic</strong></li>
<li><strong>well tested and documented</strong></li>
</ul>
<p>In thespis, interface and implementation are 2 different libraries. The idea is that the interface defines the contract of what an actor is in terms of the Rust type system, but that you can swap out the implementation with something else yet remain compatible with other code that uses actors. You could for example write an implementation which uses actix under the hood if you wanted to create interop.</p>
<p>It also means that a library that wants to expose an actor API does not need to depend on the implementation, just the interface to implement the appropriate traits.</p>
<h1 id="whats-missing"><a class="header" href="#whats-missing">What's missing</a></h1>
<ul>
<li><strong>skipping messages</strong>: The actor doesn't have access to the queue of messages. It can't observe them and decide what to process next. You could of course implement this by having a channel that allows for inspection of what's in it's buffer, but the <code>Mailbox</code> of <code>thespis_impl</code> does not deal with this for you.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pitfalls-checklist"><a class="header" href="#pitfalls-checklist">Pitfalls Checklist</a></h1>
<p>The actor model is a very convenient programming paradigm. It automatically solves many of the harder problems in concurrent software design. However, there are a few pitfalls, so here is a check list of things the compiler won't catch for us:</p>
<h2 id="1deadlocks"><a class="header" href="#1deadlocks">1.Deadlocks</a></h2>
<p>The original actor model is very simple. If you want to have a request-response type message, you had to send your own address along with the message so the recipient knows how to respond to you. Thanks to Rust's futures, we can easily create a request-response and <em>thespis</em> makes this convenient for you with <code>Address::call</code>. However, if you await a response whilst processing a message, a deadlock can arise.</p>
<p>As actors only process one message at a time. If you have a cyclic dependency, your program can deadlock. That is if actor A depends on actor B to to process it's message, but in order to process A's request B also needs to call back A, both actors will deadlock, as they are waiting on each other and will no longer process any messages ever after.</p>
<p>You can run into this problem through intermediate actors, so A and B might not be calling each other directly.</p>
<p>You can also run into this problem with a single actor when using bounded channels. If the mailbox of the actor is currently full and it sends itself a message, it will deadlock. You should generally spawn such a send to avoid blocking processing of the current message.</p>
<p>Another deadlock issue can arise when an actor is the gatekeeper of a connection (to the network or other components). That is if the mailbox of one actor accumulates both incoming and outgoing messages. If incoming messages saturate the system, and fill up the gatekeeper's mailbox, no responses can flow out. Hence no place is made for new incoming messages and everything blocks. You might want to read up on this issue <a href="https://elizarov.medium.com/deadlocks-in-non-hierarchical-csp-e5910d137cc">in this article</a> which has some nice diagrams to explain the problem and <a href="https://trio.discourse.group/t/sizing-the-channel-deadlock-freedom-vs-back-pressure">on the trio forum</a>. This problem can be solved by not using the channels for backpressure, or by using a priority channel. <em>Thespis_impl</em> has <a href="https://github.com/thespis-rs/thespis_impl/blob/dev/examples/deadlock_prio.rs">an example</a> demonstrating this last solution. Note that by using a priority channel, there is no need for unbounded channels.</p>
<h2 id="2-memory-consumption"><a class="header" href="#2-memory-consumption">2. Memory consumption</a></h2>
<p>The actor model has highly concurrent message passing. If many messages are in flight, they will all consume memory. The most obvious risk is having unbounded channels to communicate between address and mailbox. If there is no back pressure, the unbounded channel can use unbounded amounts of memory.</p>
<p>But even with bounded channels you want to keep an eye on memory consumption. If you spawn large volumes of actors, you probably want to use a channel that doesn't allocate it's full capacity. Channels based on linked lists rather than array buffers could potentially reduce a lot of memory consumption.</p>
<h2 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h2>
<p>The main downside of the actor model is a performance overhead compared to lower level approaches. Message passing has some price and depending on your application it might be a poor fit. If you have hotspots in your code, and you need to do a lot of small operations, like calling getters on other objects, the overhead of message passing might be undesirable.</p>
<p>Remember that the purpose of this model is to have an actor for everything that you want to run concurrently. However, you can have a module for which an actor is the facade to the outside world, but internally uses a synchronous logic. You do however want to reach a critical threshold of actors. If you have CPU cores x 4 components that run concurrently and that normally are rarely blocked, eg. most of them will be able to make progress most of the time, adding more concurrency to your program might not be the most useful for performance.</p>
<p>That being said, you shouldn't worry about it to much. Rust is a very performant language. Even with the overhead of message passing, it will be much faster than most other languages, and remember how much useful software has been written in those languages. In 99% of the time performance shouldn't be an issue.</p>
<p>As always, first write your software with clean design, then benchmark to see if there is a problem. If there is, profile to see what's your bottleneck.</p>
<h2 id="4-blocking"><a class="header" href="#4-blocking">4. Blocking</a></h2>
<p>We all know that async code shouldn't block. That is we shouldn't block the thread with either to much CPU intensive work, or by waiting on things like locks. That's because other tasks might also be working on the same thread.</p>
<p>However it's important to also think about blocking the task, even if you aren't blocking the thread. An actor that <code>thespis::Address::call</code>s another actor will not continue processing messages until that other actor sends back a response. Given that that actor might have a backlog of messages in it's queue, and it might itself wait for other actors whilst processing those, things could severely slow down. In practice this is not a problem if you have enough actors that can make progress at any given time. You will always have a maximal usage of the system's resources, but...</p>
<p>If you have a specific bottleneck, one or two actors that are crucial in your program that can not keep up with the rest, they become the slowest link in the chain.</p>
<p>Certain actors should spawn sub tasks rather than blocking on them. Eg. an actor that processes incoming requests from the network. If the back-end processing of those messages is async, this actor should probably continue to process other messages while the back-end generates a response. Again, it depends on the situation. If you count serving many connections concurrently and have one actor per connection, maybe it's fine for that actor to do but one thing at a time.</p>
<p>Note that <code>futures::SinkExt::send</code> also blocks the task, but only until the message has been delivered into the mailbox of the receiving actor. It doesn't wait until the message is processed, but will block if the mailbox is full.</p>
<h2 id="5-backpressure"><a class="header" href="#5-backpressure">5. Backpressure</a></h2>
<p>In any concurrent system special care always must be taken when it comes to back pressure. If your system get's flooded with incoming messages faster than they can be processed, you can have unbounded memory consumption (unbounded channels), deadlocks (bounded channels, see above) as well as CPU exhaustion. You must have a conscious plan for how backpressure is provided to slow down incoming messages. Sometimes bounded channels can be a solution if you are careful not to deadlock. Other times you will need to build a custom back pressure mechanism to to limit the number of in flight requests (this is what <em>thespis_remote</em> does).</p>
<p>You can also wrap the channel you pass to <em>thespis_impl</em> with <a href="https://lib.rs/crates/stream_throttle"><em>stream_throttle</em></a>.</p>
<p><a href="https://ferd.ca/handling-overload.html">Handling overload</a> is an interesting article from the Erlang world examining this rather difficult problem.</p>
<h2 id="6-actor-lifetime"><a class="header" href="#6-actor-lifetime">6. Actor Lifetime</a></h2>
<p>Thespis follows a model very similar to the Rust memory model. The mailbox for an actor will stop running when all addresses to this actor have been dropped and all outstanding messages have been processed. This is neat, but it does oblige you to be very conscious about where addresses are lingering, or your program won't terminate, or you might have a memory leak.</p>
<p>The initial ambition was to say an address is always valid, and thus sending can conveniently be infallible. In practice this doesn't work, since an actor might panic while processing a message. When using remote actors, the network or the remote process might go down and on top of that, most channel implementations have a fallible send.</p>
<p>I kept this lifetime management, because usually having addresses around to actors that are no longer running is a sign of sloppy coding. <em>thespis_impl</em> has support for a weak address, which will not keep the mailbox alive. This is particularly handy for situations like an actor which needs its own address, but shouldn't keep itself alive. Also be wary of two actors which have each other's address.</p>
<p>One way to sidestep this is to pull the plug. That is if you cancel the future running the mailbox, well it's terminated, however this is not recommended. If you really want an actor to stop it's own mailbox, regardless of other components that might still want to use it, you can let it spawn itself so it can have a <code>JoinHandle</code> that it can use to abort the mailbox.</p>
<p><a href="https://docs.rs/futures/0.3.15/futures/stream/fn.abortable.html"><em>futures::stream::abortable</em></a> also let's you terminate a channel receiver manually. That's another way you can stop a mailbox.</p>
<h2 id="re-entrancy"><a class="header" href="#re-entrancy">Re-entrancy</a></h2>
<p>Some actor implementations do not adhere to the one message at a time. Thespis does not have this issue. It can to some extend solve the deadlock issue described above, <a href="https://swiftsenpai.com/swift/actor-reentrancy-problem/">but it creates problems of it's own</a>. I think <em>actix</em> does this with the <code>ActorFuture</code>, but I haven't checked in a while, so take that with a grain of salt and double check.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-actors"><a class="header" href="#send-actors">!Send Actors</a></h1>
<p>In principle <em>thespis</em> should be unconcerned by whether actors and message types are <code>Send</code>. Both types are user supplied and the user
has control over what executor they use and on what threads they run actors.</p>
<p>In practice it's not so simple. Rust requires one to be specific about <code>Send</code>ness in a number of type signatures, namely for a type in a <code>Box</code>. This means that we would have to double the whole interface and implementation if we were to support <code>!Send</code> messages. I have chosen not to do this for now.</p>
<p>A compromise is made with <code>!Send</code> actors. It turns out we can support them with reasonable boilerplate. For this, <code>Handler</code> has 2 methods, <code>handle</code> and <code>handle_local</code>. Mailbox implementations should provide a way to be spawned locally, and call <code>handle_local</code> in that case.</p>
<p>The interface keeps <code>handle</code> as a required method, but <code>handle_local</code> does call <code>handle</code> by default. This means there is no change in API for <code>Send</code> actors, but when you have a <code>!Send</code> actor, you must implement <code>handle_local</code> and provide an implementation for <code>handle</code> with an <code>unreachable</code>. This should never be called.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>This is a basic example of a <code>!Send</code> actor:</p>
<pre><pre class="playground"><code class="language-rust">//! Spawn an actor that is !Send.
//
use
{
   thespis         :: { *                                         } ,
   thespis_impl    :: { Addr                                      } ,
   futures         :: { task::LocalSpawnExt, executor::LocalPool  } ,
   std             :: { marker::PhantomData, rc::Rc, error::Error } ,
};


#[ derive( Actor, Debug ) ] struct MyActor { i: u8, nosend: PhantomData&lt;Rc&lt;()&gt;&gt;}
#[ derive( Clone, Debug ) ] struct Ping( String )   ;


impl Message for Ping
{
   type Return = String;
}


impl MyActor
{
   async fn add( &amp;mut self, mut x: u8 ) -&gt; u8
   {
      x += 1;
      x
   }
}


impl Handler&lt;Ping&gt; for MyActor
{
   // Implement handle_local to enable !Send actor and mailbox.
   //
   #[async_fn_local] fn handle_local( &amp;mut self, _msg: Ping ) -&gt; String
   {
      // We can still access self across await points and mutably.
      //
      self.i = self.add( self.i ).await;
      dbg!( &amp;self.i);
      &quot;pong&quot;.into()
   }

   // It is necessary to provide handle in case of a !Send actor. It's a required method.
   // For Send actors that implement handle, handle_local is automatically provided.
   //
   #[async_fn] fn handle( &amp;mut self, _msg: Ping ) -&gt; String
   {
      unreachable!( &quot;This actor is !Send and cannot be spawned on a threadpool&quot; );
   }
}


fn main() -&gt; Result&lt; (), Box&lt;dyn Error&gt; &gt;
{
   let mut pool = LocalPool::new();
   let     exec = pool.spawner();

   let actor    = MyActor { i: 3, nosend: PhantomData };
   let mut addr = Addr::builder().spawn_local( actor, &amp;exec )?;

   exec.spawn_local( async move
   {
      let ping = Ping( &quot;ping&quot;.into() );

      let result_local = addr.call( ping.clone() ).await.expect( &quot;Call&quot; );

      assert_eq!( &quot;pong&quot;.to_string(), result_local );
      dbg!( result_local );

   })?;

   pool.run();

   Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thespis_impl"><a class="header" href="#thespis_impl">thespis_impl</a></h1>
<p>This is the reference implementation for the interface defined in the <em>thespis</em> crate. This chapter goes over it's features and provides you with example code. The most basic example, hello world:</p>
<pre><pre class="playground"><code class="language-rust">use
{
   thespis         :: { *            } ,
   thespis_impl    :: { *            } ,
   async_executors :: { AsyncStd     } ,
   std             :: { error::Error } ,
};


#[ derive( Actor ) ]
//
struct MyActor;


struct Hello( String );

impl Message for Hello
{
   type Return = String;
}


impl Handler&lt; Hello &gt; for MyActor
{
   #[async_fn] fn handle( &amp;mut self, _msg: Hello ) -&gt; String
   {
      &quot;world&quot;.into()
   }
}


#[async_std::main]
//
async fn main() -&gt; Result&lt; (), Box&lt;dyn Error&gt; &gt;
{
   // .start here spawns your mailbox/actor immediately on the given executor and
   // detaches the joinhandle. You can also use the `spawn..` functions on the builder
   // in order to get a JoinHandle which you should await as it will drop the mailbox
   // when dropped.
   //
   let mut addr = Addr::builder().start( MyActor, &amp;AsyncStd )?;

   let result = addr.call( Hello(&quot;hello&quot;.into()) ).await?;

   assert_eq!( &quot;world&quot;, result );

   Ok(())
}
</code></pre></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Let's quickly take a tour of the anatomy of this simple program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ derive( Actor ) ]
//
struct MyActor;
<span class="boring">}
</span></code></pre></pre>
<p><code>Actor</code> is a trait defined in the <em>thespis</em> crate. It has no required methods, so you can easily derive it. <code>MyActor</code> here is what generally holds the (mutable) state of your actor. In this simple example there is no state, but otherwise you can manipulate it from within the implementation of <code>Handler&lt;T&gt;</code>. The mailbox will take ownership of your actor and after that you can only communicate with it by sending messages through the address you get back. Once you give it to the mailbox you can no longer call methods on it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Hello( String );

impl Message for Hello
{
   type Return = String;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Hello</code> is a message type. The type system will guarantee that you can never send a message type to an actor unless it implements <code>Handler</code> for that type and the type implements the <code>Message</code> trait. As you will have to implement this trait for your message types, you will have to wrap types that are not defined in your crate in order to use them as a message. Here we wrap <code>String</code>. If your handler might panic, please make sure the message type is <code>UnwindSafe</code>, as the mailbox will call <code>catch_unwind</code> on the handler method. This allows us to elegantly allow supervising of actors. All together it is recommended that your handlers don't panic, rather return a <code>Result</code> if they need to be fallible. Nevertheless, messages in the actor model are meant to be data and not have any shared resources like locks or references in them.</p>
<p>The associated type is the return type of the handler. When using <code>Address::call</code> your actor can return a value to the caller, making it easy to implement request-response type communication, mimicking a method call. Sending a message to an actor is always asynchronous. Note: we could also have written <code>-&gt; &lt;Hello as Message&gt;::Return</code> as the return type here. In any case, it needs to be the same type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt; Hello &gt; for MyActor
{
   #[async_fn] fn handle( &amp;mut self, _msg: Hello ) -&gt; String
   {
      &quot;world&quot;.into()
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we define that <code>MyActor</code> can process messages of type <code>Hello</code>. The body of the function does the actual processing. As you can see it receives a <code>&amp;mut self</code>, even though we know that all messages are sent asynchronously. This is the main advantage of the actor model. Even though any place in your code that has this actor's address can easily send messages, you never need thread sync like locks or the infamous <code>Rc&lt;Refcell&gt;</code> on your data. Only this actor can access it's own state directly and the only way to communicate with it is through sending messages. Further more the mailbox will make the actor process one message at a time, so there is never shared access to the mutual state.</p>
<p>Using plain Object Oriented Programming in async Rust with methods that access state is very difficult, since as soon as you spawn any task, that task cannot hold any references to anything outside of it and to make matters worse, you shouldn't hold a mutex across an await point. The actor model sidesteps these problems, as any code that needs to communicate with an actor only needs the address, not a reference to the actor itself. <code>Addr</code> implements clone, so you can have many places of your program talk to the actor.</p>
<p>The <code>async_fn</code> macro deals with the fact that Rust doesn't support async trait methods at the moment. It does this in a very similar way as the <em>async-trait</em> crate, but it outputs much simpler code, making it compatible with a hand written version of this method, which was not possible with <em>async-trait</em>.</p>
<p>A handwritten version would look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt; Hello &gt; for MyActor
{
   fn handle( &amp;mut self, _msg: Hello ) -&gt; Return&lt;'_, String&gt;
   {
      Box::pin( async
      {
         &quot;world&quot;.into()
      })
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>Return</code> is defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A boxed future that is `Send`, shorthand for async trait method return types.
//
pub type Return&lt;'a, R&gt; = Pin&lt;Box&lt; dyn Future&lt;Output = R&gt; + 'a + Send &gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Note that within this handler you can <code>await</code> as it is asynchronous, but that while it is waiting, this actor will not process any more messages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut addr = Addr::builder().start( MyActor, &amp;AsyncStd )?;
<span class="boring">}
</span></code></pre></pre>
<p>We use a convenience builder to create the address we will use to send messages to our actor, and tell it to
generate a default mailbox for it and spawn it on the provided executor.</p>
<p>The <code>AsyncStd</code> type comes from the <em>async_executor</em> crate which provides a uniform interface for executors,
allowing us to be executor agnostic. We could just as well have given it a <em>tokio</em> executor or one from the <em>futures</em> crate, or <em>wasm-bindgen</em> on Wasm.</p>
<p>Note that this function takes our actor by value as we shouldn't access it anymore directly once it starts processing messages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = addr.call( Hello(&quot;hello&quot;.into()) ).await?;
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>Address::call</code> to send a message to our actor. This method will return to us a future that will resolve to the answer our handler returns. Note that <code>Addr</code> also implements <code>futures_sink::Sink</code>. You can use the combinators from the futures crate to forward an entire <code>Sink</code> into the address, as long as the actor implements <code>Handler</code> for the type the stream produces. The <code>send</code> method from the <code>Sink</code> trait will drop the returned value and will return to us as soon as the message is delivered to the mailbox, without waiting for the actor to process the message.</p>
<p>Thus you can also use the <code>call</code> method even if you don't want to return any value to be sure that the message has been processed, where as <code>send</code> is more like throwing a message in a bottle. You will still get back pressure from <code>send</code> as it will block when the channel between the <code>Addr</code> and the mailbox is full (as long as it's not an unbounded channel that is).</p>
<p>In the next chapter we will take a look at desugaring the builder and manually create our mailbox and address.</p>
<h2 id="weak-and-strong-addresses"><a class="header" href="#weak-and-strong-addresses">Weak and Strong addresses.</a></h2>
<p>It doesn't figure in the basic example, but the mailbox of the actor stops when all addresses to it are dropped. The <code>JoinHandle</code> from the executor will return your actor to you if you want to re-use it later. When the mailbox is stopped because your actor panicked, you will retrieve the mailbox instead and you can instantiate a new actor and spawn it on the same mailbox, so all addresses remain valid. This is further elaborated in the chapter on supervision.</p>
<p>As the mailbox future returns your actor, you must be conscious when you rely on your actor being dropped to stop other actors. The order in which you await the mailboxes can matter and sometimes you must explicitly wrap the call in <code>drop</code>.</p>
<p><em>Thespis_impl</em> also has weak addresses. These addresses don't keep the mailbox alive. It is handy when for example the actor needs it's own address. In this case you don't necessarily want it to keep itself alive. Creating a weak address is simple:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Does not consume addr, hence it's not called downgrade.
//
let weak_addr = addr.weak();

// You can create a strong address from a weak one as long as the mailbox is still open.
// If all strong addresses were already dropped at this point, you will get an error instead.
//
let strong = match weak.strong()
{
   Ok(addr) =&gt; addr,
   Err(e)   =&gt; {} // -&gt; ThesErr::MailboxClosed.
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>Important</strong>: The way the strong count works is that the mailbox only stops when the channel returns <code>Poll::Pending</code>. That is it will continue to process messages after all strong addresses are dropped. However, <code>WeakAddr</code> will refuse to take more messages from this point. Once the channel returns <code>Poll::Pending</code>, the mailbox checks the strong count. If it is zero it exits.</p>
<p>When the mailbox is already <code>Pending</code>, it will be woken up when the last strong address is dropped.</p>
<p>This can be confusing if you use <code>Poll::Pending</code> for other purposes. For example the <code>stream_throttle</code> crate allows us to throttle a channel receiver. However, that will make it return <code>Poll::Pending</code> even though the channel isn't actually empty. If there are no strong addresses, the mailbox will stop and drop those messages. As most channels and stream wrappers don't properly implement or forward <code>Stream::size_hint</code>, we have no other way to check for an empty channel but to check for <code>Poll::Pending</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desugar-addrbuilder"><a class="header" href="#desugar-addrbuilder">Desugar Addr::builder()</a></h1>
<p>Even if you will mostly be using the convenience builder to start your actors, its good to have an understanding of how things work at a lower level. So what would things look like if we wanted to manually create an actor? We will keep the simple example from the last chapter but desugar it. We already showed the desugaring of the <code>async_fn</code> macro. Here we show a full working example with the main function as desugared as we can. Just know that there are intermediate steps on the builder API if you only want to override certain parameters.</p>
<pre><pre class="playground"><code class="language-rust">use
{
   thespis         :: { *                         } ,
   thespis_impl    :: { *                         } ,
   async_executors :: { AsyncStd, SpawnHandleExt  } ,
   std             :: { error::Error              } ,
   futures         :: { channel::mpsc             } ,
};


#[ derive( Actor ) ]
//
struct MyActor;


struct Hello( String );

impl Message for Hello
{
   type Return = String;
}


impl Handler&lt; Hello &gt; for MyActor
{
   #[async_fn] fn handle( &amp;mut self, _msg: Hello ) -&gt; String
   {
      &quot;world&quot;.into()
   }
}


#[async_std::main]
//
async fn main() -&gt; Result&lt; (), Box&lt;dyn Error&gt; &gt;
{
   let (tx, rx)  = mpsc::channel( 5 );
   let tx        = Box::new( tx.sink_map_err( |e| Box::new(e) as DynError ) );
   let mb        = Mailbox::new( Some(&quot;HelloWorld&quot;.into()), Box::new(rx) );
   let mut addr  = mb.addr( tx );
   let actor     = MyActor;

   let handle = AsyncStd.spawn_handle( mb.start( actor ) )?;

   let result = addr.call( Hello( &quot;hello&quot;.into() ) ).await?;

   assert_eq!( &quot;world&quot;, dbg!(result) );

   // This allows the mailbox to close. Otherwise the await below would hang.
   //
   drop( addr );

   // The JoinHandle will allow you to recover either your actor or the mailbox.
   //
   let actor = match handle.await
   {
      MailboxEnd::Actor(a) =&gt; a,

      // This would happen if your actor had panicked while handling a message.
      //
      MailboxEnd::Mailbox(_mailbox) =&gt; unreachable!(),
   };

   Ok(())
}
</code></pre></pre>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>In thespis you can choose what channel will be used for communication between the address and the mailbox. Out of the box the builder supports futures channels, in bounded and unbounded forms. But you might want to try a different channel type. One interesting application is if you want to use a channel that overwrites older messages instead of providing back pressure, like the one in the <em>ring-channel</em> crate.</p>
<p>The abstractions the thespis types work on are defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// Interface for T: Sink + Clone
//
pub trait CloneSink&lt;'a, Item, E&gt;: Sink&lt;Item, Error=E&gt; + Unpin + Send
{
   /// Clone this sink.
   //
   fn clone_sink( &amp;self ) -&gt; Box&lt; dyn CloneSink&lt;'a, Item, E&gt; + 'a &gt;;
}


impl&lt;'a, T, Item, E&gt; CloneSink&lt;'a, Item, E&gt; for T

   where T: 'a + Sink&lt;Item, Error=E&gt; + Clone + Unpin + Send + ?Sized

{
   fn clone_sink( &amp;self ) -&gt; Box&lt; dyn CloneSink&lt;'a, Item, E&gt; + 'a &gt;
   {
      Box::new( self.clone() )
   }
}


/// A boxed error type for the sink.
//
pub type DynError = Box&lt; dyn std::error::Error + Send + Sync &gt;;

/// Type of boxed channel sender for Addr.
//
pub type ChanSender&lt;A&gt; = Box&lt; dyn CloneSink&lt; 'static, BoxEnvelope&lt;A&gt;, DynError&gt; &gt;;

/// Type of boxed channel receiver for Mailbox.
//
pub type ChanReceiver&lt;A&gt; = Box&lt; dyn futures::Stream&lt;Item=BoxEnvelope&lt;A&gt;&gt; + Send + Unpin &gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Thus the sender must implement <code>Sink</code>, <code>Clone</code>, <code>Unpin</code> and <code>Send</code> and it's error type must be <code>Box&lt; dyn std::error::Error + Send + Sync &gt;</code>. The receiver must be infallible and implement <code>Stream</code>, <code>Send</code> and <code>Unpin</code>. If your favorite channel implementation does not provide the <code>Sink</code> interface on it's sender, you can often wrap them and implement the <code>Sink</code> yourself.</p>
<h2 id="mailbox-and-addr"><a class="header" href="#mailbox-and-addr">Mailbox and Addr</a></h2>
<p>Next we create our mailbox and address:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mb       = Mailbox::new( Some(&quot;HelloWorld&quot;.into()), Box::new(rx) );
let mut addr = mb.addr( tx );
<span class="boring">}
</span></code></pre></pre>
<p>The first parameter on <code>Mailbox::new</code> is an optional name. This will be used in logging to help you identify which actor is doing what.  Every mailbox created in the process will also have a unique numeric id, but you can also name them to make it easier to understand your logs. <code>Addr</code> also exposes both the <code>id()</code> and <code>name()</code>. If two addresses return the same <code>id</code>, they both talk to the same mailbox and thus actor.</p>
<p>We feed both ends of the channel to the constructors of <code>Mailbox</code> and its <code>addr</code> method. You may notice that we just created both the mailbox and the address without even having instantiated an actor yet. That is because we only really need an actor when we start the mailbox. This has an interesting property. If we want our actor to have a copy of it's own address, we can just pass it along in it's constructor, since as soon as we start it we can only communicate to it through messages. It would be a bit of a pain to have to create a specific message type to give the actor it's own address.</p>
<h2 id="starting-the-mailbox"><a class="header" href="#starting-the-mailbox">Starting the mailbox</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let actor  = MyActor;
let handle = AsyncStd.spawn_handle( mb.start( actor ) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Next we create an actor and pass it to <code>Mailbox::start</code>. This method returns a future that you can spawn however way you like on the executor of your choice.</p>
<p>We use the <code>AsyncStd</code> wrapper from <em>async_executors</em> here. One essential difference with using <code>async-std</code> directly is that the joinhandle this returns will cancel the future when you drop it, which is a way you can stop an actor. The recommended way is to drop all addresses to the actor.</p>
<h2 id="stopping-the-actor"><a class="header" href="#stopping-the-actor">Stopping the actor</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>drop( addr );
handle.await;
<span class="boring">}
</span></code></pre></pre>
<p>As described above, to drop an actor we drop all addresses to it. Now we can await the mailbox which will terminate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supervising-an-actor"><a class="header" href="#supervising-an-actor">Supervising an actor</a></h1>
<p>A common pattern in actor software is supervision. The idea is to monitor a hierarchy of actors and if any one crashes, it's supervisor will spawn a new one to replace it. This is a strategy for more robust software. In terms of Rust actors, I would rather suggest you try to make your handlers panic free, and let them return a <code>Result</code> that you can handle if they are fallible, but that is not always possible and you can use the supervision pattern with thespis.</p>
<p>The following example is relatively straightforward. The main feature allowing supervising in thespis is that the mailbox future returns the mailbox to you if the actor panics while processing a message. This means that you can just instantiate a new actor and spawn the mailbox again and it will be fully operational. All addresses to it will just remain valid.</p>
<p><strong>Warning</strong>: This does mean that mailbox uses catch unwind on your handlers. That means your messages should be unwindsafe, but as you shouldn't be using shared mutability anyway this should already be the case.</p>
<pre><pre class="playground"><code class="language-rust">use
{
   thespis           :: { *                    } ,
   thespis_impl      :: { *                    } ,
   tracing           :: { *                    } ,
   futures::task     :: { Spawn, SpawnExt      } ,
   std               :: { error::Error         } ,
   async_executors   :: { AsyncStd, JoinHandle } ,
};


#[ derive( Actor ) ] struct Counter;

struct Add(usize);


impl Message for Add  { type Return = usize; }


// This is a silly actor, if you send it an even number, it panics.
// Otherwise it returns your number to you.
//
impl Handler&lt; Add &gt; for Counter
{
   #[async_fn] fn handle( &amp;mut self, msg: Add ) -&gt; usize
   {
      if msg.0 % 2 == 0 { panic!(); }

      msg.0
   }
}


// Actor that can supervise other actors. It will start the actor for the first time
// if it's not already started.
//
#[ derive( Actor ) ]
//
struct Supervisor
{
   // We will need to spawn the mailbox again if the actor panics, so we need an executor.
   // If you want to make this more hierarchical, you can use a nursery from the async_nursery
   // crate to tie all these subtasks to the lifetime of the supervisor and prevent them from
   // getting orphaned.
   //
   exec: Box&lt;dyn Spawn + Send&gt;
}


// The message we will be sending.
//
struct Supervise&lt;A: Actor&gt;
{
   mailbox : Option&lt; JoinHandle&lt;MailboxEnd&lt;A&gt;&gt;&gt; &gt; ,

   // A closure that knows how to instantiate the supervised actor.
   // You could also require that A: Default.
   //
   create: Box&lt; dyn FnMut() -&gt;A + Send &gt; ,
}

impl&lt;A: Actor + Send&gt; Message for Supervise&lt;A&gt;
{
   type Return = Option&lt; Addr&lt;A&gt; &gt;
}


// Note how the actor type is a generic parameter, so this supervisor works for
// actors of any type.
//
impl&lt;A: Actor + Send&gt; Handler&lt; Supervise&lt;A&gt; &gt; for Supervisor
{
   #[async_fn] fn handle( &amp;mut self, mut actor: Supervise&lt;A&gt; ) -&gt; Option&lt; Addr&lt;A&gt; &gt;
   {
      let mut addr = None;

      let mut mb_handle = if actor.mailbox.is_none()
      {
         let (addr_new, mb_handle) = Addr::builder().start_handle( (actor.create)(), &amp;AsyncStd ).unwrap();

         addr = Some(addr_new);

         mb_handle
      }

      else { actor.mailbox.take().unwrap() };


      let supervisor = async move
      {
         // This is where the magic happens. Every time the handle resolves, we spawn again
         // and replace it with a new handle.
         //
         // When this returns MailboxEnd::Actor, it means the actor has stopped naturally and we don't respawn it.
         //
         while let MailboxEnd::Mailbox(mb) = mb_handle.await
         {
            mb_handle = mb.start_handle( (actor.create)(), &amp;AsyncStd ).unwrap();
         }
      };

      self.exec.spawn( supervisor ).unwrap();

      addr
   }
}


#[async_std::main]
//
async fn main() -&gt; Result&lt; (), Box&lt;dyn Error&gt; &gt;
{
   tracing_subscriber::fmt::Subscriber::builder()

      .with_max_level( Level::DEBUG )
      .init()
   ;

   let mut supervisor = Addr::builder().start( Supervisor{ exec: Box::new( AsyncStd ) }, &amp;AsyncStd )?;


   // Here we use a closure to create new actors, but if you don't need to capture
   // anything from the environment you might as well just implement `Default` for
   // your actor type.
   //
   let create = Box::new( ||
   {
      debug!( &quot;Creating a new Counter&quot; );
      Counter
   });

   let supervise = Supervise
   {
      create,
      mailbox: None,
   };

   let mut addr = supervisor.call( supervise ).await?.unwrap();

   // Both of these will make the actor panic:
   //
   assert!(matches!( addr.call( Add(10) ).await, Err( ThesErr::ActorStoppedBeforeResponse{..} ) ));
   assert!(matches!( addr.send( Add(10) ).await, Ok(()) ));

   // Yet, our actor is still responding.
   //
   assert_eq!( addr.call( Add(11) ).await, Ok(11) );

   Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processing-messages-concurrently"><a class="header" href="#processing-messages-concurrently">Processing messages concurrently</a></h1>
<p>In principle an actor processes one message at a time. This restriction only makes sense however if the actor has mutable state. This avoids all synchronization problems. But what if your actor doesn't have mutable state? In that case we can process messages concurrently without any issues.</p>
<p>The following example also shows how you can tie the lifetime of the sub-tasks to the lifetime of the actor by using a nursery:</p>
<pre><pre class="playground"><code class="language-rust">use
{
   thespis           :: { *                                                 } ,
   thespis_impl      :: { *                                                 } ,
   std               :: { error::Error                                      } ,
   futures           :: { FutureExt, task::{ SpawnError }                   } ,
   async_executors   :: { AsyncStd, SpawnHandle, SpawnHandleExt, JoinHandle } ,
   async_nursery     :: { Nursery, NurseErr, Nurse, NurseExt                } ,
};


type DynError = Box&lt;dyn Error + Send + Sync&gt;;


#[ derive( Actor ) ]
//
struct MyActor
{
   // We store the nursery_handle on our actor. That way the lifetime of all
   // tasks inside the nursery is tied to the lifetime of our actor. If we drop
   // the actor, all subtasks that are still running will be dropped.
   //
   // Alternatively we could have a Handler for a Stop message, which would await
   // the nursery_handle to wait for all subtasks to finish before dropping this actor.
   // That last one can even be combined with a timeout to limit how long we wait for
   // subtasks to finish naturally before dropping them.
   //
   nursery: Box&lt; dyn Nurse&lt;()&gt; + Send &gt;,
   _nursery_handle: JoinHandle&lt;()&gt;,
}


struct Ping;

impl Message for Ping { type Return = Result&lt;(), NurseErr&gt;; }


impl MyActor
{
   pub fn new( exec: impl SpawnHandle&lt;()&gt; + Clone + Send + 'static ) -&gt; Result&lt;Self, SpawnError&gt;
   {
      let (nursery, output) = Nursery::new( Box::new( exec.clone() ) );

      let _nursery_handle = exec.spawn_handle( output )?;
      let nursery         = Box::new( nursery );

      Ok( Self
      {
          nursery        ,
         _nursery_handle ,
      })
   }
}


impl Handler&lt;Ping&gt; for MyActor
{
   // For this usecase we don't use the `async_fn` macro since we don't want our entire
   // handler to be in the returned future. We want to set some thing up first.
   //
   fn handle( &amp;mut self, _msg: Ping ) -&gt; Return&lt;'_, &lt;Ping as Message&gt;::Return &gt;
   {
      // If self had properties wrapped in Arc, we could clone them here to pass them
      // into the future.
      //
      // However we can't actually pass the reference to self in if we want it
      // to run concurrently.
      //
      // In theory you can have something in an Arc&lt;Mutex&gt;&gt; or atomic variables, but
      // you really must be careful. As these run concurrently, values will change in the
      // middle of processing which is a footgun.
      //
      // If we would need to update self with the result of an async operation, we can
      // store our own address on self, clone that to pass it into the spawned task
      // and send the result to ourselves.
      //
      let processing = async move
      {
         // do something useful.
      };

      // Processing will now run concurrently.
      //
      let result = self.nursery.nurse( processing );

      // If spawning failed, we pass that back to caller.
      // We are now immediately ready to process the next message even while processing is
      // still running.
      //
      // We return the result of processing to the caller.
      //
      async move { result }.boxed()
   }
}


#[async_std::main]
//
async fn main() -&gt; Result&lt; (), DynError &gt;
{
   let     actor = MyActor::new( Box::new(AsyncStd) )?;
   let mut addr  = Addr::builder().start( actor, &amp;AsyncStd )?;

   // Admittedly, this looks a bit weird. Call is fallible, and it returns a result over
   // the NurseErr, since the handler needs to spawn and spawning is fallible.
   //
   addr.call( Ping ).await??;

   Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-the-actor-type"><a class="header" href="#abstract-the-actor-type">Abstract the Actor type</a></h1>
<p>The last chapters cover the most straight forward use of thespis. But how does it all compose? What if need to store a list of addresses to different actors that accept a certain type of message? What if I have to send 2 different message types to this heterogeneous list? <code>Addr</code> is actually <code>Addr&lt;A&gt;</code>. It's generic over a type of actor, thus it can send all the message types this actor implements <code>Handler</code> for, but that does mean we can not store a list of addresses to different actors.</p>
<p>The solution to this is the trait <code>Address&lt;M&gt;</code> from the interface library <em>thespis</em>. We can store a <code>Box&lt; dyn Address&lt;M, Error=E&gt; + Send + Unpin &gt;</code> and thus we can store addresses to different actors in the same collection. Because this type is unwieldy, thespis has a shorthand: <code>BoxAddress&lt;M, E&gt;</code>. The error type comes from the channel Sender. <em>thespis_impl</em> wraps the errors from different channels in <code>ThesErr</code>, so generally if you use the <code>Addr</code> type, that's the error type you should use.</p>
<p>Of course, if your actor types are known at compile time and you don't have to many of them you can also use an enum:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Postman
{
   Foo( Addr&lt;Foo&gt; ),
   Bar( Addr&lt;Bar&gt; ),
}
<span class="boring">}
</span></code></pre></pre>
<p>However, you will have to match and de-structure the enum to actually send anything. And mind you that sometimes boxing doesn't have any measurable overhead, so the inconvenience might well not be worth it.</p>
<h1 id="multi-dimensional"><a class="header" href="#multi-dimensional">Multi dimensional</a></h1>
<p>But what if you have several message types and you will have to send them to several types of actors? Unfortunately we <a href="https://github.com/rust-lang/rfcs/issues/2035">cannot currently express</a> <code>Box&lt; dyn Address&lt;Foo&gt; + Address&lt;Bar&gt; &gt;</code> in rust. There is a piece of boilerplate that solves this however:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

impl Message for Foo { type Return = (); }
impl Message for Bar { type Return = (); }


trait AddressFooBar: Address&lt;Foo, Error=ThesErr&gt; + Address&lt;Bar, Error=ThesErr&gt; {}

impl&lt;T&gt; AddressFooBar for T

   where Self: Address&lt;Foo, Error=ThesErr&gt; + Address&lt;Bar, Error=ThesErr&gt;
{}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can have <code>Box&lt; dyn AddressFooBar &gt;</code> and be able to send both <code>Foo</code> and <code>Bar</code> messages. The <a href="https://crates.io/crates/trait_set">trait_set</a> crate can make this more streamlined.</p>
<h1 id="unknown-unknowns"><a class="header" href="#unknown-unknowns">Unknown unknowns</a></h1>
<p>Sometimes it's not even known in your library which types of actors and which types of messages you will have to handle, because they are user defined. Yet you still need to store a bunch addresses. You will need some other information at runtime that indicates which type the actor and message are, to enable downcasting.</p>
<p>In this case you can store the addresses as <code>Box&lt; dyn Any &gt;</code> and then downcast them at runtime to the right type. We can store a collection eg. <code>HashMap</code> of <code>Box&lt; dyn Any &gt;</code> and downcast them to <code>Box&lt; dyn Address&lt;M, E&gt; &gt;</code>. You will need to store (eg. in the keys of your hashmap) what type you are actually holding to downcast it. See the <a href="https://github.com/thespis-rs/thespis_impl/tree/master/examples/recipient_any.rs">recipient_any example</a>.</p>
<h1 id="cloning-trait-objects"><a class="header" href="#cloning-trait-objects">Cloning trait objects</a></h1>
<p>The clone trait is not object safe in Rust, so you can't make a trait object from a trait that requires implementers to also implement <code>Clone</code>. For this reason, the <code>Address</code> trait has a <code>clone_box</code> method that requires implementors to be able to produce a <code>BoxAddress&lt;M&gt;</code>. This way if you have a boxed address you can still clone it conveniently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Debugging asynchronous programs can be a bit of a challenge. <em>thespis_impl</em> tries to give you the relevant information and tooling to succeed in seeing exactly what is going on in your program. The main feature is generating useful logs about what's going on so you can check what each concurrent component is doing.</p>
<p><em>thespis_impl</em> uses <a href="https://crates.io/crates/tracing"><em>tracing</em></a> for it's logging. Its possibility of instrumenting futures and executors with spans (through <a href="https://crates.io/crates/tracing-futures_"><em>tracing-futures</em></a>) makes it uniquely suitable for logging in async applications.</p>
<p>Whenever the <code>Mailbox</code> runs, it will enter a <code>Span</code> identifying your actor by id and name. Log events within <code>Addr</code> and <code>WeakAddr</code> will also be within such span. This will help you identify which actor messages are coming from. It is important you choose a subscriber that prints span information.</p>
<p>In order to turn on logging, setup a basic tracing subscriber. You can add this to the beginning of your main function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = tracing_subscriber::fmt::Subscriber::builder().init();
<span class="boring">}
</span></code></pre></pre>
<p>One thing to note is that if within your handler you spawn on an executor, you will lose the association with the current <code>Span</code>. However you can use <code>tracing::current_span()</code> to get the <code>Span</code> and now you can use <code>tracing-futures</code> to instrument the future you want to spawn. Alternatively you can create a new <code>Span</code> and set the actor's <code>Span</code> as the parent.</p>
<p>In any case, anything you log in your handler will be tagged with the actor's span, but if you spawn new tasks, you will have to manually include a span if you want to avoid losing the association with the actor.</p>
<h2 id="using-the-log-crate"><a class="header" href="#using-the-log-crate">Using the log crate</a></h2>
<p>If your application uses the log crate, but you want to receive the log events emitted by <em>thespis_impl</em>, please refer to <a href="https://docs.rs/tracing/0.1.26/tracing/index.html#log-compatibility">the relevant documentation of the tracing crate</a>.</p>
<h2 id="visualizing-logs"><a class="header" href="#visualizing-logs">Visualizing logs</a></h2>
<p>The usual problem with async logs is that you will get all log lines interleaved. This makes it very hard to reason about what is going on. The tracing spans <em>thespis_impl</em> adds allow us to know which actor a log event is associated with. This means we can separate out logs per actor and put them side by side.</p>
<p>I wrote a little web app called <a href="https://github.com/najamelan/tracing_prism">tracing_prism</a> that lets you visualize your logs in columns. By using the names or id's of your actors as filters, you can see the flow of several concurrent components side by side. For best results, generate your logs in json format:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = tracing_subscriber::fmt::Subscriber::builder()
	.json()
	.init()
;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backpressure"><a class="header" href="#backpressure">Backpressure</a></h1>
<p>Backpressure is an important concept in asynchronous message based systems. Backpressure allows receivers to slow down senders when they cannot process messages/requests fast enough. This limits the memory consumption and improves latency.</p>
<p>The most basic form of back pressure in thespis can be achieved by using bounded channels for mailboxes. This will make sender tasks wait before putting messages in a mailbox that is full. Thereby slowing down parts of the process that are outpacing other parts. There is a number of situations in which this can work well, but there is one particular trap. By creating a circular shape with one actor acting as a gate to the outside world, receiving and sending to the outside, you can create a deadlock.</p>
<p>The issue is described at length with illustrations in <a href="https://elizarov.medium.com/deadlocks-in-non-hierarchical-csp-e5910d137cc">this article</a>. Please go read that and then come back.</p>
<p>The solution to this problem in it's simplest form is indeed to have a separate outgoing queue for the gateway actor. In thespis this is relatively simple with the use of <code>futures::stream::select_with_strategy</code>. There is also a demonstration of this in the <a href="https://github.com/thespis-rs/thespis_impl/blob/dev/examples/deadlock_prio.rs">examples directory</a>.</p>
<p>However, this is only the most simple form of this problem. This is a closed circuit with one node that acts as a gateway. Eg. manages the incoming and outgoing messages. So when we have a priority queue, the incoming messages do not fill up the outgoing queue and as soon as the processing actor (or pipeline for that matter) can offload a response, they will get a new message from their mailbox. This free slot will propagate all the way back to the gateway. The gateway can now offload the current message to the processing actor and will now processe the outgoing message first (as it'a priority queue). Thus, the system cannot deadlock.</p>
<p>However imagine the gateway is a client connection to our server. And imagine we can have more than 1 client connected at the same time (well, it's a big motivator for async architecture, isn't it). Now our solution no longer works. As now all the client connections are competing for new free slots in the processing actor/pipeline. If it so happens that the gateway which received outgoing messages in their outgoing queue loses this competition, it's possible that their outgoing queue fills up and hopla. Deadlock 2.0.</p>
<p>A solution for this problem is to forgo the mailboxes for back pressure and to use a separate system, like a semaphore. Gateways need permits before sending more requests into the system. This works, but it's not trivial to define exactly what is the right number of permits here, especially if someone might come along later and change the architecture of the system.</p>
<p>Also, it only solves our exact problem. Yes, things can get worse. What if the processing pipeline isn't exactly linear, but a complex application? What if some of those actors can actually create new messages that end up in the system? You'd have to make absolutely sure that they reserve a slot in the semaphore before doing so, if not the semaphore no longer accurately keeps track of the number of messages that are currently in the system. What if they can create new actors? </p>
<p>An oft suggested solution to all of this is to use unbounded channels. There are however several problems with them. First of all, it means no more backpressure. In itself that's fine as we established that using the mailbox as a backpressure mechanism in this case is a bad idea. However more fundamentally the problem is that unbounded channels don't exist. They would require unbounded memory, which most systems don't have, as well as create unbounded latency which is generally not desirable. </p>
<p>Another solution is to let the gateway spawn a new task for every incoming message, making it completely resistant against this type of deadlock. However here an external back pressure mechanism like a semaphore becomes really important, otherwise we have a situation similar to unbounded channels, which doesn't really work.</p>
<p>There is in my opinion no one size fits all solution here. You must carefully think your architecture through, and be conscious about your queue-sizes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-thespis_remote"><a class="header" href="#introduction-to-thespis_remote">Introduction to thespis_remote.</a></h1>
<p><em>Thespis_remote</em> adds support for remote actors to the thespis actor model. It follows the same rather low level approach as the rest of <em>thespis</em>. That means it provides the ability to send actor messages over one connection. The connection <em>thespis_remote</em> works over is a <code>Sink</code> and <code>Stream</code> of a given wire format. The wire format has an encoder/decoder so works over anything that implements <code>AsyncRead</code>/<code>AsyncWrite</code>.</p>
<p>There is no &quot;system&quot; or service discovery integrated. It requires you to connect two processes by any means of your choice and provide the above interfaces to <em>thespis_remote</em>. From there <em>thespis_remote</em> provides:</p>
<ul>
<li><code>RemoteAddr</code> which allows you to send messages as if you were sending to an actor in the same process (only difference, <code>send</code> does not guarantee in order delivery within the remote process).</li>
<li><code>ServiceMap</code>, a trait and provided reference impl that knows how to deserialize your actor messages and dispatch them to the right actor. Note that you can only set one actor per message type per service map, so you are actually sending to a remote process rather than to an individual actor in that process. However you can easily wrap your message with an actor id and provide more precise delivery if you want.</li>
<li><code>WireFormat</code>, a trait and reference impl (using CBOR) for the actual wire format used.</li>
<li><code>Peer</code>, an actor that manages a connection endpoint. You provide it with a service map to &quot;serve&quot; over the connection and for sending messages, you pass it's address to the constructor of <code>RemoteAddr</code>, implying that you know that the other side of the connection managed by this <code>Peer</code> exposes these services. This last part is the only thing we cannot guarantee in the type system, as the compiler does not know about the process on the other end of your connection.</li>
</ul>
<p>These are the four core components of the library.</p>
<p><em>thespis_remote</em> also provides relaying of messages. Further some features are included to deal with back pressure and to make it resistant to attacks like DOS and slow loris.</p>
<p>Apart from this guide you can also consult the <a href="https://docs.rs/thespis_remote">API documentation</a> and the <a href="https://github.com/thespis-rs/thespis_remote/tree/master/examples">examples</a>.</p>
<h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>The scope of <em>thespis_remote</em> is specifically as described above. On the low end of the scope this means there is no management of your connection. When the connection fails, <code>Peer</code> will generate an event for you to react on. You have to re-connect and re-setup your <code>Peer</code> and service map. This limitation is necessary to keep the scope of the project reasonable as many different types of connections can be used. You can obviously write your own wrapper that provides automatic reconnect and maybe in the future something like that will be provided by the thespis project, but it won't be in <em>thespis_remote</em>.</p>
<p>On the high end of the scope, <em>thespis_remote</em> does not handle any application logic. Most prominently authentication/authorization comes to mind. What if a user has to authenticate before being allowed to send certain messages to your service. It generally comes down to 2 key components: prevent MITM by end to end encryption (do this on the connection level) and sending along some proof of identity (think cookie in HTTP land). <em>thespis_remote</em> does not have any instrumentation for this and it will be up to you to handle this in your message types.</p>
<p>You might feel cheated that you can't address individual actors on a remote process. There are good reasons for this however and nothing stops you from implementing individual actor addressing on top of <em>thespis_remote</em>. In <em>thespis</em> everything is as much as possible statically type checked. By considering a process that exposes it's possibility to receive messages of certain types, we adhere to a public interface like a contract. It allows a remote process to statically create addresses to send us messages, rather than having to send over addresses at runtime.</p>
<p>Actors can accept several types of messages, but some of those might not be meant for external use. If we were to expose an address to a specific actor type as is, all of it's interface would be remotely exposed. We would also need to compile in the actor type in the remote process, where with the current design only message types need to be shared between the two processes.</p>
<p><em>thespis_remote</em> is minimal in the sense that it creates the fundamental building block for remote actor communication. Systems, discovery and individual actor addressing can all be implemented on top of it.</p>
<p>Several components of the library can easily be customized. The traits <code>WireFormat</code> and <code>ServiceMap</code> allow you to create your own specialized implementations if desired.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servicemap"><a class="header" href="#servicemap">ServiceMap</a></h1>
<p>A service map is a type that knows how to deliver messages to individual actors. It dispatches if you will. You can tell <code>Peer</code> to expose a set of services remotely by bundling them in a <code>ServiceMap</code> and registering that map.</p>
<p>This makes it possible to expose different sets of services on different connections. For the moment it is not possible to dynamically change what services are exposed at runtime. The problem here is that we consider the service map a contract between two processes, so if all of a sudden we would stop providing certain services, the remote process might run into errors. This might change in the future, with some thought of how we inform a remote process of what services are available at any given time. One purpose might be to deal with authentication, enabling certain services only once a user has authenticated. However for now you have to deal with authentication yourself by adding a token in your messages. The receiving actor doesn't actually know which connection a message comes from.</p>
<p>There are three implementations of <code>ServiceMap</code> provided by <em>thespis_remote</em>:</p>
<ul>
<li><code>service_map!</code>, a macro</li>
<li><code>RelayMap</code>, used for relaying messages to a different process.</li>
<li><code>PubSub</code>, for relays to implement a publish/subscribe architecture.</li>
</ul>
<h2 id="service_map"><a class="header" href="#service_map"><code>service_map!</code></a></h2>
<p>This is a macro because as it needs to deserialize your actor messages, it needs to know it's types, but that can only be provided inside your crate, not in <em>thespis_remote</em>. Thus it gives you all that functionality that needs to be in your crate to make things convenient so you don't have to write that yourself. It's main use looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use
{
   thespis_remote :: { CborWF, service_map    } ,
   serde          :: { Serialize, Deserialize } ,
};

// Compared to local actor messages, remote once must also implement Serialize and Deserialize from Serde.
//
#[ derive( Serialize, Deserialize, Debug ) ] pub struct Add( pub i64 );
#[ derive( Serialize, Deserialize, Debug ) ] pub struct Show;

impl Message for Add  { type Return = ();  }
impl Message for Show { type Return = i64; }


// Remember that WireFormat is a trait. _thespis_remote_ is generic over the actual type, but it surely is part
// of the contract between 2 processes what wire format is being used. So you have to specify it for the macro.
//
service_map!
(
   namespace  : my_fancy_app_com ;
   wire_format: CborWF           ;
   services   : Add, Show        ;
);
<span class="boring">}
</span></code></pre></pre>
<p>The meaning of the parameters:</p>
<ul>
<li><strong>namespace</strong>: this will be transformed into a module in your code. It is also used to uniquely identify services to avoid name collisions.</li>
<li><strong>wire_format</strong>: The wire format used for connections that expose this service map, in this case <code>CborWF</code>, the default implementation provided by <em>thespis_remote</em>.</li>
<li><strong>services</strong>: The message types that will be served by this service map.</li>
</ul>
<p><strong>Usually you will put this macro as well as the message types mentioned in a separate crate that can be compiled into both processes that will communicate to eachother.</strong></p>
<p>You can of course interact with such process also from binaries written in different languages as long as they correctly speak the wire format.</p>
<p>Usage of <code>service_map!</code> looks like this on the side that exposes these services:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use
{
   thespis         :: { Actor, async_fn } ,
   thespis_impl    :: { Addr            } ,
   async_executors :: { AsyncStd        } ,
};

// Let's imagine a simple actor that can receive `Sum` and `Show`.
//
#[ derive(Actor) ] pub struct Sum( pub i64 );

impl Handler&lt;Add&gt; for Sum
{
   #[async_fn] fn handle( &amp;mut self, msg: Add ) -&gt; ()
   {
      self.0 += msg.0;
   }
}


impl Handler&lt; Show &gt; for Sum
{
   #[async_fn] fn handle( &amp;mut self, _msg: Show ) -&gt; i64
   {
      self.0
   }
}

// Create mailbox for our handler and start it using async-std as the executor.
// The type of addr_handler is `Addr&lt;Sum&gt;`.
//
let addr_handler = Addr::builder().spawn( Sum(0), &amp;AsyncStd )?;

// Create a service map.
//
let mut sm = my_fancy_app_com::Services::new();

// Register our handler. In this case the same actor will handle both types of messages.
//
sm.register_handler::&lt;Add &gt;( addr_handler.clone_box() );
sm.register_handler::&lt;Show&gt;( addr_handler.clone_box() );

// Register sm with a peer. See next chapter.
// ...
<span class="boring">}
</span></code></pre></pre>
<p>On the side that wants to use the service, you can obtain a <code>RemoteAddr</code> that accepts all the message types declared in the <code>service_map</code> macro. This cannot be statically verified by the compiler as the other side is generally another process. So you basically declare that you know that the process on the other end accepts messages of this type. Apart from this, everything is statically type checked in <em>thespis</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Call the service and receive the response.
//
let mut addr = my_fancy_app_com::RemoteAddr::new( peer_addr );

assert_eq!( Ok(()), addr.call( Add(5) ).await );
assert_eq!( Ok(()), addr.send( Add(5) ).await );
assert_eq!( Ok(10), addr.call( Show   ).await );
<span class="boring">}
</span></code></pre></pre>
<p><code>RemoteAddr</code> works pretty much like <code>thespis::Addr</code>, except for the error type which will be <code>PeerErr</code> instead of <code>ThesErr</code> because a lot more things can go wrong when dealing with messaging over a network connection and you probably want to know what went wrong when it does.</p>
<h1 id="relaymap"><a class="header" href="#relaymap">RelayMap</a></h1>
<p>A <code>RelayMap</code> has the same place in the workflow as <code>Services</code> created by the <code>service_map!</code> macro, but instead of delivering to a local actor it passes on the message to a <code>Peer</code> that is connected to another process. This allows for transparent relaying to other backend services.</p>
<p>To create the <code>RelayMap</code>, you give it a <code>ServiceHandler</code> and a list of <code>ServiceID</code>s that should be relayed. Then you register it as a service map with the Peer that is listening for the incoming requests just as <code>Services</code>.</p>
<p>The <code>ServiceHandler</code> is an enum that is either an address to a <code>Peer</code> or a closure that will provide an address on a case by case basis. The latter option allows you to do load balancing or other runtime checks/logs before producing the address.</p>
<p>For a working code example, check the <a href="https://github.com/thespis-rs/thespis_remote/tree/master/examples/relay">relay example</a> for <em>thespis_remote</em>.</p>
<h1 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h1>
<ul>
<li>TODO</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peer"><a class="header" href="#peer">Peer</a></h1>
<p>The <code>Peer</code> is the workhorse of <em>thespis_remote</em>. It manages a connection for you once you give it an <code>Stream + Sink</code> of the wireformat. It is generic over a <code>WireFormat</code>.</p>
<p>On the incoming path what it does looks like:</p>
<ol>
<li>It spawns a loop that reads incoming messages from the connection and deserializes them into the wire format struct. If then looks at what type of message it is to apply back pressure to calls but no to other types of message.</li>
<li>This loop sends those to the <code>Peer</code> as messages, as the peer is an actor.</li>
<li>Unless the message is an error or a reponse to a request we made, we look up if we have a service map that handles this message type. We then spawn a task and tell the service map to deliver the message. This prevents the <code>Peer</code> from being blocked while a message is being processed. It means it can still process outgoing messages as well as process several incoming messages concurrently.</li>
</ol>
<p>When an outgoing message is a call (request/response) the peer will send a oneshot channel back to the caller. Next it will store the sender of that channel with the <code>ConnID</code>, which later allows detecting that an incoming message is a response to this request and send the answer through the oneshot channel.</p>
<p><code>Peer</code> does not do connection management like reconnect on loss etc. It is observable and will emit an event if the connection closes. It's up to you to handle that and potentially reconnect.</p>
<p>The easiest way to create the peer is from an <code>AsyncRead</code>/<code>AsyncWrite</code>. Wireformats must have a method for that. Lets have a look:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use 
{
	async_executors::AsyncStd,
	thespis_remote::{ CborWf },
};

let (peer, peer_mb, peer_addr) = CborWF::create_peer
( 
	&quot;server&quot;             , // a name for this connection
	tcp_connection       , // A transport that implements AsyncRead/AsyncWrite
	1024                 , // Max read message size for the codec (in bytes)
	1024                 , // Max write message size for the codec (in bytes)
	Arc::new( AsyncStd ) , // An executor to spawn tasks
	None                 , // an optional semaphore for backpressure
	None                 , // an optional grace period to finish outstanding tasks when closing down

).expect( &quot;create peer&quot; );
<span class="boring">}
</span></code></pre></pre>
<p>See the documentation on the WireFormat trait for some more explanation. You can also use the slightly more low level <code>Peer::new</code> if you want more control. That expects a <code>Stream</code>/<code>Sink</code> of the wire format as well as 2 thespis addresses. One for incoming messages and one for outgoing messages, as it allows you to set up a priority queue with the <code>futures::stream::select_with_strategy</code> combinator making sure outgoing messages are prioritized. This is especially useful if your process accepts requests to improve latency and lower memory consumption. It can also lower the risk of deadlocks, but that will be further explained in the chapter on backpressure.</p>
<p>Once the peer is created as shown above, we can continue the example from the chapter on <code>ServiceMap</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use 
{
	async_executors::AsyncStd,
	std::sync::Arc,
};

// Register service map with peer
//
peer.register_services( Arc::new( sm ) );

// Start the peer actor
//
let peer_handle = AsyncStd.spawn_handle( peer_mb.start(peer) ).expect( &quot;start mailbox of Peer&quot; );

// Wait for the connection to close, which will automatically stop the peer.
//
peer_handle.await;

<span class="boring">}
</span></code></pre></pre>
<h2 id="backpressure-1"><a class="header" href="#backpressure-1">Backpressure</a></h2>
<p><code>Peer</code> is a gateway in the sense described in the <a href="https://thespis-rs.github.io/thespis_guide/thespis_impl/backpressure.html">earlier chapter on backpressure</a>. It uses both a semaphore as well as a priority channel. </p>
<p>Further more <code>Peer</code> spawns a new task for each incoming message. This guarantees it doesn't deadlock. As processing messages is asynchronous, and might even be relayed to other processes, this also means we can keep processing incoming messages concurrently rather than blocking and doing it serially.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
